'
' cody_audio.spin
' SID-inspired audio generation for the Cody Computer.
' 
' Copyright 2024 Frederick John Milens III, The Cody Computer Developers.
' 
' This program is free software; you can redistribute it and/or
' modify it under the terms of the GNU General Public License
' as published by the Free Software Foundation; either version 3
' of the License, or (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
'
' SUMMARY
' 
' A rudimentary emulation of the Commodore/MOS Sound Interface Device (SID) for the
' Cody Computer. The SID's three voices are supported along with the standard waveforms,
' ring modulation, sync, and ADSR envelopes. Combined waveforms, filters, and more
' advanced features are not supported. Registers are mapped to the same locations in
' memory as on the C64, though not all are used:
' 
' $D400     Voice 1 frequency low byte
' $D401     Voice 1 frequency high byte
' $D402     Voice 1 pulse duty cycle low byte
' $D403     Voice 1 pulse duty cycle high byte (nibble)
' $D404     Voice 1 control register
' $D405     Voice 1 attack (high nibble) and decay (low nibble)
' $D406     Voice 1 sustain (high nibble) and release (low nibble)
' $D407     Voice 2 frequency low byte
' $D408     Voice 2 frequency high byte
' $D409     Voice 2 pulse duty cycle low byte
' $D40A     Voice 2 pulse duty cycle high byte (nibble)
' $D40B     Voice 2 control register
' $D40C     Voice 2 attack (high nibble) and decay (low nibble)
' $D40D     Voice 2 sustain (high nibble) and release (low nibble)
' $D40E     Voice 3 frequency low byte
' $D40F     Voice 3 frequency high byte
' $D410     Voice 3 pulse duty cycle low byte
' $D411     Voice 3 pulse duty cycle high byte (nibble)
' $D412     Voice 3 control register
' $D413     Voice 3 attack (high nibble) and decay (low nibble)
' $D414     Voice 3 sustain (high nibble) and release (low nibble)
' $D415     Reserved (filters?)
' $D416     Reserved (filters?)
' $D417     Reserved (filters?)
' $D418     Volume control (filters?)
' $D419     Reserved
' $D41A     Reserved
' $D41B     Voice 3 oscillator read
' $D41C     Voice 3 envelope read
' 
' Compatibility with actual C64 SID code is variable at best, both due to emulation 
' difficulties and hardware differences between the Cody Computer and the Commodore 64.
' Successes include David Dunn's "Star Trek: The Rebel Universe" theme, Tom Snyder's
' theme to "Agent USA," and Richard Bayliss' version of "Jingle Bells." The sound effects
' generator and "Tom Dooley" examples from the C64 User Guide were ported and worked from
' Cody Basic. Consider the Cody "SID" a SID-like device suitable for porting code to it.
' 
' Audio output is generated by the Propeller's counter running in the duty single-ended
' mode with output on I/O pin 27. This connects to a circuit similar to that suggested
' by Parallax's Paul Baker in a forum posting (https://forums.parallax.com/discussion/88372).
' 
' Much of the code is a port of the GPL-licensed "MOS6581 SID Emulator Arduino Library" by 
' Christoph Haberer and Mario Patino (https://github.com/cybernesto/sid-arduino-lib).
' Some inspiration also came from SIDcog by Johannes Ahlebrand and Ada Gottenstr√§ter,
' a more accurate emulation available on the Parallax OBEX (https://obex.parallax.com/).
'
  _CLKMODE = xtal1 + pll16x     
  _XINFREQ = 5_000_000  

'
' Starts the audio cog using the specified memory location as the start of shared
' memory. The cog will map all emulated registers/memory addresses relative to it.
'
PUB start(mem_ptr)

    cognew(@cogmain, mem_ptr)
  
DAT             org 0

'
' Entry point of the audio cog. Updates various pointers and constants based on
' the pointer to shared memory, then enables audio output on the Propeller.
'
cogmain
                ' Calculate actual position of registers
                add     REGS_BASE, PAR
                add     OSC3_PTR, PAR
                add     ENV3_PTR, PAR
                
                ' Configure output for sound
                mov     dira, INIT_DIRA
                mov     ctra, INIT_CTRA
                
                ' Configure timing
                mov     time, cnt
                add     time, WAIT_TIME
                
                mov     output, #0

'
' Main loop that iterates over each voice and calculates output values, then
' combines them into a single output.
'
main_loop

:loop
                ' Wait for next cycle
                waitcnt time, WAIT_TIME
                
                ' Update noise
                mov     temp, noise
                and     temp, #$1
                neg     temp, temp
                and     temp, NOISE_BITS
                shr     noise, #1
                xor     noise, temp
                and     noise, MASK_16
                
                ' Start at beginning of internal voice states on each main loop
                movs    readvar, #state1
                movd    savevar, #state1
                
                ' Start at beginning of registers on each main loop
                mov     register_ptr, REGS_BASE
                
                ' Three voices to process
                mov     voice_count, #3
:voice_loop           
                call    #voice_begin
                call    #make_wave
                call    #make_envelope
                call    #make_waveform
                call    #voice_end
                
                djnz    voice_count, #:voice_loop
                
                ' Combine into a single output
                call    #make_output
                
                ' Repeat the main loop
                jmp     #:loop

'
' Voice loop executed once for each of the three voices. Reads the voice's registers
' from shared memory into cog memory, copies state variables into temporary variables,
' and performs some initial checks about sync and test bits.
'
voice_begin
                ' Read the registers for a single voice into COG memory
                movd    :readreg, #voice_freq_l
                mov     count, #7
:readreg        rdbyte  0-0, register_ptr
                add     :readreg, INC_DEST
                add     register_ptr, #1
                djnz    count, #:readreg
                
                ' Copy the internal states for the current voice into temp vars
                movd    readvar, #state
                mov     count, #7
readvar         mov     0-0, 0-0
                add     readvar, INC_BOTH
                djnz    count, #readvar
                
                ' Sync voice if the other voice indicates it's time to sync,
                ' test if sync bit is on AND it's time to sync (order is)
                ' reversed because we're counting down).
                cmp     voice_count, #2                     wc,wz
if_nc           movd    :testsync, #sync3     ' Voice 1 uses voice 3
if_z            movd    :testsync, #sync1     ' Voice 2 uses voice 1
if_c            movd    :testsync, #sync2     ' Voice 3 uses voice 2
                nop
:testsync       test    0-0, voice_control                  wz
if_nz           mov     phase, #0
                
                ' Reset voice if the test bit is on
                test    voice_control, #$08                 wz
if_nz           mov     phase, #0
if_nz           mov     amplitude, #0
if_nz           mov     state, #0

voice_begin_ret ret

'
' Makes the wave for the current voice based on oscillator settings. The current
' value is calculated based on frequency settings, the phase accumulator, and the
' selected waveform.
'   
make_wave
                ' Combine frequency into 16 bit number
                ' Shift by 2 because frequency * 4000 / 16 KHz sample rate
                mov     freq_coefficient, voice_freq_h
                shl     freq_coefficient, #8
                or      freq_coefficient, voice_freq_l
                shr     freq_coefficient, #2
                
                 ' Calculate next phase
                mov     temp_phase, phase
                add     temp_phase, freq_coefficient
                
                ' If we overflowed, set our internal sync bit to apply later
                testn   temp_phase, MASK_16                 wz
                muxnz   sync, #$02
                
                ' Limit phase calculation to 16 bits internally
                and     temp_phase, MASK_16
                
:triangle       
                ' Triangle waveform?
                test    voice_control, #$10                 wz
if_z            jmp     #:sawtooth
                
                ' Time to invert? (Goes up half the time, then down half the time)
                ' Double the value to make sure it covers the full range
                mov     wave, phase
                test    wave, BIT_15                        wz
                shl     wave, #1
if_nz           xor     wave, MASK_16
                and     wave, MASK_16
                jmp     #:done
                
:sawtooth       
                ' Sawtooth waveform?
                test    voice_control, #$20                 wz
if_z            jmp     #:pulse
            
                mov     wave, phase
                jmp     #:done

:pulse          
                ' Pulse waveform?
                test    voice_control, #$40                 wz
if_z            jmp     #:noise
                
                mov     temp, voice_pulse_h
                shl     temp, #8
                or      temp, voice_pulse_l
                shl     temp, #4
                and     temp, MASK_16
                
                cmp     phase, temp                         wc
if_c            mov     wave, MASK_16
if_nc           mov     wave, #0
                
                jmp     #:done
                
:noise          
                ' Noise waveform?
                test    voice_control, #$80                 wz
if_z            jmp     #:done
        
                mov     temp, phase
                xor     temp, temp_phase
                test    temp, PHASEBIT_NOISE                wz
if_nz           mov     temp, noise
if_nz           and     temp, MASK_16
if_nz           mov     wave, temp

:done
                ' Update phase for the current voice (limited to unsigned 16 bits)
                mov     phase, temp_phase
                    
                ' Ensure wave only has 16 bits of resolution
                and     wave, MASK_16

make_wave_ret   ret

'
' Makes the envelope for the current voice, calculating the value based on
' the current place in the ADSR envelope.
'
make_envelope
                ' Is gate bit set? (playing a note?)
                test    voice_control, #$01                 wz
if_z            jmp     #:release
                
:attack         
                ' Gate bit set, but are we on attack or decay state?
                tjnz    state, #:decay
                
                ' Increment amplitude with attack value from table
                movs    :addattack, #ATTACK_RATES
                mov     temp, voice_attack_decay
                shr     temp, #4
                add     :addattack, temp
                nop
:addattack      add     amplitude, 0-0
               
                ' Did we reach the maximum value (end of attack portion?)
                cmp     amplitude, MAXLEVEL                 wc
if_c            jmp     #:done
                
                ' Cap at maximum amplitude, enter decay phase
                mov     amplitude, MAXLEVEL
                mov     state, #1
                
                jmp     #:done

:decay          
                ' Look up the matching sustain value from the table
                mov     temp, voice_sustain_release
                shr     temp, #4
                add     temp, #SUSTAIN_LEVELS
                movs    :getsustain, temp 
                nop
:getsustain     mov     level_sustain, 0-0
                
                ' Did we reach that sustain level?
                cmp     level_sustain, amplitude            wc
if_nc           jmp     #:done
        
                ' Subtract the current decay value from our amplitude,
                ' but don't let our amplitude fall below zero
                mov     temp, voice_attack_decay
                and     temp, #$0F
                add     temp, #DECAY_RATES 
                movs    :subdecay, temp
                nop   
:subdecay       sub     amplitude, 0-0                      wc
if_c            mov     amplitude, #0
                
                ' Limit amplitude from falling below sustain level
                min     amplitude, level_sustain
                
                jmp     #:done
                        
:release
                ' Gate bit is off so not in attack state
                mov     state, #0
                
                ' Have we reached zero amplitude?
                tjz     amplitude, #:done
                
                ' Subtract the current decay value from our amplitude,
                ' but don't let our amplitude fall below zero
                mov     temp, voice_sustain_release
                and     temp, #$0F
                add     temp, #DECAY_RATES
                movs    :subrelease, temp
                nop   
:subrelease     sub     amplitude, 0-0                      wc
if_c            mov     amplitude, #0
                
                ' Scale envelope from 24 to 16 bits resolution
:done           mov     envelope, amplitude
                shr     envelope, #8

make_envelope_ret   ret

'
' Make the actual waveform for the voice using the current wave value and
' the curent ADSR envelope value.
' 
make_waveform
                ' We'll be multiplying the wave value by the envelope value
                mov     x, wave
                
:ring
                ' Ring modulation bit?
                test    voice_control, #$04                 wz
if_z            jmp     #:done
                
                ' For "ring modulation" we invert the wave based on another's phase
                ' (Order is reversed because we're counting down)
                cmp     voice_count, #2                     wc,wz
if_nc           movd    :testphase, #phase3   ' Voice 1 uses voice 3
if_z            movd    :testphase, #phase1   ' Voice 2 uses voice 1
if_c            movd    :testphase, #phase2   ' Voice 3 uses voice 2
                nop
:testphase      test    0-0, BIT_15                         wz
if_nz           xor     x, MASK_16
        
:done           
                ' Multiply the wave by the envelope
                mov     y, envelope
                call    #multiply
                
                ' Scale result down from 32 to 16 bits
                shr     y, #16
                mov     output, y

make_waveform_ret   ret
     
'
' Once a voice has been processed, copy working variables back to the voice's own
' variables in cog memory.
'
voice_end
                movs    savevar, #state
                mov     count, #7
savevar         mov     0-0, 0-0
                add     savevar, INC_BOTH
                djnz    count, #savevar

voice_end_ret   ret

'
' Combine outputs from each voice into the resulting PWM signal out of the
' Propeller. Also update the oscillator 3 and envelope 3 registers with the
' current values of each.
' 
make_output     
                ' Read the filter registers
                movd    :readfilt, #filter_cutoff_l
                mov     count, #4
:readfilt       rdbyte  0-0, register_ptr
                add     :readfilt, INC_DEST
                add     register_ptr, #1
                djnz    count, #:readfilt
                
                ' Combine outputs (voice 3 is a special case)
                mov     x, output1
                add     x, output2
               
                ' Voice 3 is skipped if bit is set
                test    filter_mode_volume, #$80            wz
if_z            add     x, output3
                
                ' Apply volume setting
                mov     y, filter_mode_volume
                and     y, #$0F
                call    #multiply
                shr     y, #4
                
                ' Scale output value to Propeller PWM value 
                mov     output, y
                sub     output, BIT_15
                shl     output, #11
                add     output, BIT_31
                mov     frqa, output
                
                ' Write high byte of voice 3 oscillator waveform
                mov     temp, wave3
                shr     temp, #8
                wrbyte  temp, OSC3_PTR  
                
                ' Write high byte of voice 3 envelope
                mov     temp, envelope3
                shr     temp, #8
                wrbyte  temp, ENV3_PTR
                
make_output_ret ret

'
' Multiplies two 16-bit numbers in x and y into a single 32-bit number in y.
' Taken from the Parallax Propeller manual (version 1.1), "Appendix B: Math
' Samples and Function Tables" under "Multiplication, Division, and Square
' Root."
'
multiply        
                shl     x, #16      ' Get multiplicand into x high bits
                mov     t, #16      ' Ready for 16 multiplier bits
                shr     y,  #1  wc  ' Get initial multiplier bit into c
:loop               

if_c            add     y, x    wc  ' If carry set, add multiplicand into product
                rcr     y, #1   wc  ' Get next multiplier bit into c, shift product
                
                ' Loop until done
                djnz    t,  #:loop
                  
multiply_ret    ret

voice_freq_l            long    0               ' One set of SID voice registers (taken from https://www.c64-wiki.com/wiki/SID)
voice_freq_h            long    0
voice_pulse_l           long    0
voice_pulse_h           long    0
voice_control           long    0
voice_attack_decay      long    0
voice_sustain_release   long    0

filter_cutoff_l         long    0               ' SID filter registers (taken from https://www.c64-wiki.com/wiki/SID)
filter_cutoff_h         long    0
filter_res_routing      long    0
filter_mode_volume      long    0

state1                  long    0               ' Variables for voice 1 (order is important)
phase1                  long    0
wave1                   long    0
sync1                   long    0
envelope1               long    0
amplitude1              long    0
output1                 long    0

state2                  long    0               ' Variables for voice 2 (order is important)
phase2                  long    0
wave2                   long    0
sync2                   long    0
envelope2               long    0
amplitude2              long    0
output2                 long    0

state3                  long    0               ' Variables for voice 3 (order is important)
phase3                  long    0
wave3                   long    0
sync3                   long    0
envelope3               long    0
amplitude3              long    0
output3                 long    0

state                   long    0               ' Working variables for the voice currently being calculated
phase                   long    0
wave                    long    0
sync                    long    0
envelope                long    0
amplitude               long    0
output                  long    0

freq_coefficient        long    0
level_sustain           long    0

noise                   long    $ACE1           ' Variable for the noise generator (Galois linear feedback shift register)

time                    long    0
temp                    long    0
temp_phase              long    0
other_phase             long    0
count                   long    0

voice_count             long    0
register_ptr            long    0

x                       long    0               ' Variables for multiplication routine 
y                       long    0
t                       long    0

BIT_15                  long    $8000           ' Mask for bit 15
BIT_31                  long    $80000000       ' Mask for bit 31
MASK_16                 long    $FFFF           ' Mask for the low 16 bits of a word

REGS_BASE               long    $3400           ' SID base register location in shared memory
OSC3_PTR                long    $341B           ' Oscillator 3 output register location in shared memory
ENV3_PTR                long    $341C           ' Envelope 3 output register location in shared memory

INIT_DIRA               long    (1 << 27)                                   ' Output pin for audio
INIT_CTRA               long    %0_00110_000_00000000_000000_000_011011     ' Duty single-ended mode, pin 27 output
WAIT_TIME               long    (80_000_000 / 16_000)                       ' 16 KHz sampling frequency like the Siduino

NOISE_BITS              long    $B400           ' Value to AND with the current LFSR value (for noise generation)

PHASEBIT_NOISE          long    $4000           ' Phase accumulator bit to check when generating noise values
PHASEBIT_RING           long    $8000           ' Phase accumulator bit to check when performing ring modulation

INC_DEST                long    (1 << 9)        '
INC_BOTH                long    ((1 << 9) | 1)

FILTER_MIN              long    -32768
FILTER_MAX              long    32767

MAXLEVEL                long    ($FFFFFF / 3)   ' Maximum amplitude level for a voice (used in ADSR calculations)

' Attack rate lookup table for 16 KHz
ATTACK_RATES            long    (($FFFFFF / 3) / (16 * 2))
                        long    (($FFFFFF / 3) / (16 * 4))
                        long    (($FFFFFF / 3) / (16 * 16))
                        long    (($FFFFFF / 3) / (16 * 24))
                        long    (($FFFFFF / 3) / (16 * 38))
                        long    (($FFFFFF / 3) / (16 * 58))
                        long    (($FFFFFF / 3) / (16 * 68))
                        long    (($FFFFFF / 3) / (16 * 80))
                        long    (($FFFFFF / 3) / (16 * 100))
                        long    (($FFFFFF / 3) / (16 * 250))
                        long    (($FFFFFF / 3) / (16 * 500))
                        long    (($FFFFFF / 3) / (16 * 800))
                        long    (($FFFFFF / 3) / (16 * 1000))
                        long    (($FFFFFF / 3) / (16 * 3000))
                        long    (($FFFFFF / 3) / (16 * 5000))
                        long    (($FFFFFF / 3) / (16 * 8000))

' Decay rate lookup table for 16 KHz
DECAY_RATES             long    (($FFFFFF / 3) / (16 * 6))
                        long    (($FFFFFF / 3) / (16 * 24))
                        long    (($FFFFFF / 3) / (16 * 48))
                        long    (($FFFFFF / 3) / (16 * 72))
                        long    (($FFFFFF / 3) / (16 * 114))
                        long    (($FFFFFF / 3) / (16 * 168))
                        long    (($FFFFFF / 3) / (16 * 204))
                        long    (($FFFFFF / 3) / (16 * 240))
                        long    (($FFFFFF / 3) / (16 * 300))
                        long    (($FFFFFF / 3) / (16 * 750))
                        long    (($FFFFFF / 3) / (16 * 1500))
                        long    (($FFFFFF / 3) / (16 * 2400))
                        long    (($FFFFFF / 3) / (16 * 3000))
                        long    (($FFFFFF / 3) / (16 * 9000))
                        long    (($FFFFFF / 3) / (16 * 15000))
                        long    (($FFFFFF / 3) / (16 * 24000))
                        
' Sustain levels and their mappings to 24 bits
SUSTAIN_LEVELS          long    (($FFFFFF / 3) * 0)
                        long    (($FFFFFF / 3) * 1)
                        long    (($FFFFFF / 3) * 2)
                        long    (($FFFFFF / 3) * 3)
                        long    (($FFFFFF / 3) * 4)
                        long    (($FFFFFF / 3) * 5)
                        long    (($FFFFFF / 3) * 6)
                        long    (($FFFFFF / 3) * 7)
                        long    (($FFFFFF / 3) * 8)
                        long    (($FFFFFF / 3) * 9)
                        long    (($FFFFFF / 3) * 10)
                        long    (($FFFFFF / 3) * 11)
                        long    (($FFFFFF / 3) * 12)
                        long    (($FFFFFF / 3) * 13)
                        long    (($FFFFFF / 3) * 14)
                        long    (($FFFFFF / 3) * 15)
                        
                        fit     496
